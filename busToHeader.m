function busToHeader(busName, headerPath, busInfo, pragmas)
% *************************************************************************
% File:         <a href="matlab:amp('busToHeader.m')">busToHeader.m</a>
%
% Functions:    busToHeader(busName, headerPath, busInfo, pragmas)
%
% Description:  Convert a bus object (passed by name or definition) to the
%               appropriate typedef'd header file for use with simulink
%               coder. Files, if existing, will be appended with new buses
%               and if needed existing buses modified.
%
%               I dont know why TMW do not provide a function that does the
%               same given they use one for codegen and provide the oposite
%               function (Simulink.importExternalCTypes).
%               
%               THE AUTOGENERATED FILE MUST NOT BE MODIFIED BY HAND ELSE 
%               THE FUNCTION MAY DESTROY THE FILE CONTENTS.
%
% Arguments:    busName:
%                   bus object named with the value in busInfo, or name of 
%                   bus that may be found in the given workspace (busInfo).
%               headerPath:
%                   name of the header file to write or append.
%               busInfo:
%                   for buses passed by name the dictionary or workspace
%                   where we will be able to find the named bus. For nested
%                   busses we should also be able to find these buses here.
%                   For buses passed by object this is the bus name.
%               pragmas:
%                   linux pragmas appended to end of typedef, typically
%                   used for padding and allignment. Use alignment 8
%                   without packing for generated code to match simulink on
%                   a 64 bit machine.
%
% Useage:       busToHeader('busName', 'busDefinitions.h', 'base', [])
%               busToHeader(busObject, 'busDefinitions.h', 'myBusName', [])
%
% Revisions:    1.00 01/09/20 (tf) first release
%
% SPDX-License-Identifier: Apache-2.0
% *************************************************************************

%% busToHeader

assert(nargin == 4, 'Function needs 4 inputs, the last may be empty');
pragmas = getPragmas(pragmas);
[~, headerName, headerExt] = fileparts(headerPath);
defName = upper(matlab.lang.makeValidName([headerName headerExt]));
[busObject, busName] = getBusObject(busName, busInfo);
busList = [];
busIndex = 1;
busData = generateBusDefinition(busObject, busName, pragmas);
busPreable = generateBusPreamble(busName);

% Read old file if it exists
if (exist(headerPath, 'file') == 2)
    headerContent = readFileAndRemoveGuards(headerPath, defName);
    busList = getBusDefinitions(headerContent);
    busIndex = find(ismember({busList.Name}, busName));
    if any(busIndex)
        if strcmp(busList(busIndex).Data, busData)
            return 
        else
            warning(['Bus defintion for "%s" exists in file, but '...
                'objects differs so editing header file.'], busName);
        end
    else 
        busIndex = numel(busList) + 1;
    end
end

busList(busIndex).Name = busName;
busList(busIndex).Comment = busPreable;
busList(busIndex).Data = busData;

% Write the actual file here
fileStr = generateFilePreamble();
fileStr = [fileStr openHeaderGuards(defName)];
fileStr = [fileStr addHeaderIncludes()];
for n = 1 : numel(busList)
    fileStr = [fileStr writeBusInfo(busList(n))];
end
fileStr = [fileStr closeHeaderGuards(defName)];

fid = fopen(headerPath,'w');
fprintf(fid,'%s',fileStr);
fclose(fid);

end

function pragmas = getPragmas(pragmas)
    if isempty(pragmas) && isunix()
        pragmas = '__attribute__((aligned(8)))';
    end
end

function [busObject, busName] = getBusObject(busName, busInfo)
    % deal with all permisable busName and busWorkspace options.
    if isa(busName, 'Simulink.Bus')
        busObject = busName;
        busName = busInfo;
    else
        if strcmp(busInfo, 'base')
            busObject = evalin(busInfo, busName);
        elseif ischar(busInfo) && endsWith(busInfo,'.sldd')
            busDictionary = Simulink.data.dictionary.open(busInfo);
            busSection = getSection(busDictionary,'Design Data');
            busEntry = getEntry(busSection,busName);
            busObject = getValue(busEntry);
        elseif isa(busInfo, 'Simulink.ModelWorkspace')
            busObject = getVariable(busInfo, busName);
        else
            error('Bad busName / busInfo combination');
        end
    end
end

function str = generateFilePreamble()
    dateStr = datestr(now,'dd/mm/yy HH:MM');
    str = sprintf(['// Autogenerated header file last changed on %s\n'...
        '// Do not modify anypart of this file\n'], dateStr);
end

function str = openHeaderGuards(defName)
    str = sprintf('#ifndef _%s_\n#define _%s_\n', defName, defName);
end

function str = addHeaderIncludes()
    % this may be somewhere else on windows / mac
    tmwTypes = fullfile(matlabroot,'extern','include','tmwtypes.h');
    str = sprintf('#include "%s"\n\n', tmwTypes);
end

function str = writeBusInfo(busInfo)
    str = sprintf('%s%s', busInfo.Comment, busInfo.Data);
end

function str = closeHeaderGuards(defName)
    str = sprintf('#endif _%s_', defName);
end

function opType = compiledTypeName(ipType)
    matlabType = {'double', 'single', 'uint32', 'int32', 'uint16', ...
        'int16', 'uint8','int8','boolean'};
    cType = {'real_T', 'real32_T', 'uint32_T', 'int32_T', 'uint16_T',...
        'int16_T', 'uint8_T', 'int8_T', 'boolean_T'};
    match = ismember(matlabType, ipType);
    if any(match == true) 
        opType = cType{match};
    else
        opType = strtrim(regexprep(ipType,'^Bus: ',''));
    end
end

function busData = generateBusDefinition(busObject, busName, pragmas)
    busData = sprintf('typedef struct {\n');
    for n = 1 : numel(busObject.Elements)
        name = busObject.Elements(n).Name;
        count = prod(busObject.Elements(n).Dimensions);
        type = compiledTypeName(busObject.Elements(n).DataType);
        if count == 1
            busData = [busData sprintf('\t%s %s;\n', type, name)]; 
        else
            busData = [busData sprintf('\t%s %s[%d];\n',type, name, count)];
        end
    end
    busData = [busData sprintf('} %s %s;\n\n', pragmas, busName)];
end %#ok<*AGROW>

function busPreamble = generateBusPreamble(busName)
    busPreamble = sprintf('// Bus Definition: %s\n// Generated on: %s\n',...
        busName, datestr(now,'dd/mm/yy HH:MM'));
end

function fileBody = readFileAndRemoveGuards(fileName, defName) 
    fileContent = fileread(fileName);
    startDefs = sprintf('^#ifndef _%s_\n#define _%s_\n\n', defName, defName);
    endDefs = sprintf('#endif _%s_$', defName);
    fileBody = regexprep(fileContent, {startDefs, endDefs}, '');
end

function busInfo = getBusDefinitions(busses)
    splitTerm = '// Bus Definition: .+?\n// Generated on: .+?\n';
    busNames = regexp(busses, '(?<=// Bus Definition: ).+?(?=\n)','match');
    N = numel(busNames);
    if N == 0 
        busInfo = struct('Name',{},'Comment',{},'Data',{});
        return
    end
    busInfo(N) = struct('Name','','Comment','','Data','');
    busComments = regexp(busses, splitTerm,'match');
    busDefs = regexp(busses, splitTerm,'split');
    busDefs(cellfun(@(x) ~startsWith(x,'typedef struct {'),busDefs)) = [];
    assert((numel(busComments) == N && numel(busDefs) == N), ...
        'Bad bus file, comments at top of each bus must not be changed.')
    for n = 1 : N
        busInfo(n).Name = busNames{n};
        busInfo(n).Comment = busComments{n};
        busInfo(n).Data = busDefs{n};
    end
end
